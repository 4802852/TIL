## 로그인 with Bcrypt

로그인 과정

1. client 에서 req.body 전송
2. 해당 이메일이 데이터베이스에 있는지 확인
3. 일치하는 이메일이 있다면 비밀번호가 일치하는지 확인
4. 비밀번호도 일치한다면 토큰 생성

### login route 작성

```
// index.js
app.post('/login', (req, res) => {
    // 로그인
})
```

### 이메일 일치하는 유저 데이터 있는지 확인

```
// index.js
app.post('/login', (req, res) => {
    User.findOne({ email: req.body.email }, (err, user) => {
        // 입력된 이메일이 없다면
        if (!user) return res.json({
            loginSuccess: false,
            message: "이메일을 확인해주세요.",
        })

        // 이메일이 있다면
        ...

    })
})
```

User 의 findOne 을 이용하여 req.body.email 을 이용하여 입력된 이메일을 데이터베이스에 확인해주고, 확인하고 나면 err, user 를 callback 해준다.

만약 이메일이 없다면 user 객체가 없을 것이기 때문에 !user 라면 로그인 실패와 실패 이유를 전송한다.

### 비밀번호 일치 확인

데이터베이스의 비밀번호는 암호화되어있고, 이를 복호화하는 것은 불가능하다. 따라서 이를 비교하기 위해서는 동일하게 입력받은 비밀번호를 암호화하여 암호화된 값 끼리 비교해야 한다.

비교하는 함수는 User 모델에서 작성한다.

```
// models/User.js
userSchema.mothods.comparePassword = function (plainPassword, cb) {
    bcrypt.compare(plainPassword, this.password, function (err, isMatch) {
        if (err) return cb(err);
        cb(null, isMatch);
    });
};
```

userSchema 에서 comparePassword 메소드를 만들고, plainPassword 를 입력받고, cb 콜백 함수를 리턴한다.

bycrypt 를 이용하여 plainPassword 와 this.password(암호화된) 를 비교하여, 일치하지 않을 경우 err 를 리턴하고, 그렇지 않을 경우 isMatch 를 리턴한다.

```
// index.js
app.post('/login', (req, res) => {
    User.findOne({ email: req.body.email }, (err, user) => {
        // 입력된 이메일이 없다면
        ...

        // 이메일이 있다면
        user.comparePassword(req.body.password, (err, isMatch) => {
            if (!isMatch) return res.json({
                loginSucess: false,
                message: "비밀번호가 틀렸습니다.",
            })

            // 비밀번호가 일치하면 토큰 생성
            ...
        })

    })
})
```

### 유저 토큰 생성

